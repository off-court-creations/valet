{
  "name": "Tree",
  "status": "experimental",
  "docs": {
    "bestPractices": [
      "Use stable ids. Provide deterministic `id`s for nodes so expanded/selected state can be controlled and persisted across renders.",
      "Keep labels compact. Tree rows should be glanceable; favor short labels and use variants (`list` or `files`) to convey structure.",
      "Align behavior with expectations. Support Arrow keys, Enter/Space for selection, and Left/Right to collapse/expand; let doubleâ€‘click toggle when appropriate.",
      "Choose control model. Use `expanded` / `onExpandedChange` and `selected` / `onNodeSelect` when external state or routing must drive the tree; otherwise use defaults.",
      "Avoid overâ€‘nesting. Deep hierarchies are hard to scan; flatten where possible and consider search/filter affordances for large trees.",
      "Tokenized spacing. Use theme spacing for indentation so density and breakpoints scale predictably."
    ]
  },
  "examples": [
    {
      "id": "tree-chevrons",
      "title": "Chevron variant",
      "code": "(() => {\n  const data = [\n    { id: 'fruit', data: { label: 'Fruit' }, children: [\n      { id: 'apple', data: { label: 'Apple' } },\n      { id: 'banana', data: { label: 'Banana' } }\n    ]}\n  ];\n  return (<Tree nodes={data} getLabel={(n) => n.label} defaultExpanded={['fruit']} variant='chevron' />);\n})()"
    },
    {
      "id": "tree-files",
      "title": "Files variant",
      "code": "(() => {\n  const files = [\n    { id: 'src', data: { label: 'src' }, children: [\n      { id: 'index.ts', data: { label: 'index.ts' } }\n    ]}\n  ];\n  return (<Tree nodes={files} getLabel={(n) => n.label} defaultExpanded={['src']} variant='files' />);\n})()"
    }
  ]
}
