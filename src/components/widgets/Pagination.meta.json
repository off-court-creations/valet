{
  "name": "Pagination",
  "status": "experimental",
  "aliases": ["pagination", "pager", "paginator"],
  "docs": {
    "bestPractices": [
      "Keep visible pages small. For large `count`, set a reasonable `siblingCount` and rely on first/last controls.",
      "Sync state when relevant. Mirror page in the router (query or path) so refresh/back behaves predictably.",
      "Prefer serverâ€‘side slicing for large datasets; ensure Table or List reflects the current page cleanly.",
      "Use accessible labels and titles for buttons (Prev/Next) and indicate current page to assistive tech.",
      "Consider infinite scroll for content feeds where paging is less meaningful.",
      "Align placement near the data it controls and avoid duplicating controls unless justified."
    ]
  },
  "examples": [
    {
      "id": "pagination-controlled",
      "title": "Controlled pagination",
      "code": "() => {\n  const [page, setPage] = React.useState(1);\n  return (<Stack>\n    <Pagination count={12} page={page} onChange={setPage} />\n    <Typography>Current page: {page}</Typography>\n  </Stack>);\n}"
    },
    {
      "id": "pagination-window",
      "title": "Visible window + autoFollow",
      "code": "() => {\n  const [page, setPage] = React.useState(5);\n  const [follow, setFollow] = React.useState(true);\n  return (<Stack>\n    <Pagination count={50} visibleWindow={7} autoFollowActive={follow} page={page} onChange={setPage} />\n    <Stack direction='row' sx={{ alignItems: 'center' }}>\n      <Typography variant='subtitle'>autoFollowActive</Typography>\n      <Switch checked={follow} onChange={setFollow} aria-label='toggle autoFollowActive' />\n    </Stack>\n  </Stack>);\n}"
    }
  ]
}
